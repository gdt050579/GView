name: "Reusable Build (composite)"
description: "Configure, build, (optionally) test and upload artifacts with CMake"
inputs:
  build_type:
    description: "CMake build type"
    default: "Release"
  enable_tests:
    description: "Run tests? ('true'|'false')"
    default: "false"
  use_vcpkg_cache:
    description: "Cache vcpkg artifacts? ('true'|'false')"
    default: "true"
  upload_artifact:
    description: "Upload build artifact? ('true'|'false')"
    default: "false"
  artifact_path:
    description: "Path (glob) to upload when upload_artifact=true"
    default: "bin/Release/**"
  jobs_count:
    description: "Number of parallel jobs for build (string number, '0' = auto)"
    default: "0"
  sign_binaries:
    description: "Sign the binaries using a keyless method"
    default: "false"
runs:
  using: "composite"
  steps:
    # --------------------------
    # NOTE: Do NOT checkout here.
    # Let the caller run actions/checkout so this can be used after CodeQL init.
    # --------------------------

    # --------------------------
    # Compute JOBS count
    # --------------------------
    - name: Set JOBS (Linux/macOS)
      if: ${{ runner.os != 'Windows' }}
      shell: bash
      run: |
        if [ "${{ inputs.jobs_count }}" = "0" ]; then
          echo "JOBS=$(nproc 2>/dev/null || sysctl -n hw.ncpu)" >> "$GITHUB_ENV"
        else
          echo "JOBS=${{ inputs.jobs_count }}" >> "$GITHUB_ENV"
        fi

    - name: Set JOBS (Windows)
      if: ${{ runner.os == 'Windows' }}
      shell: pwsh
      run: |
        if ("${{ inputs.jobs_count }}" -eq "0") {
          "JOBS=$env:NUMBER_OF_PROCESSORS" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ASCII
        } else {
          "JOBS=${{ inputs.jobs_count }}" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ASCII
        }

    # --------------------------
    # Cache vcpkg
    # --------------------------
    - name: Compute vcpkg.json hash
      id: vcpkg_hash
      if: ${{ runner.os != 'Windows' }}
      shell: bash
      run: |
        if [ -f "vcpkg.json" ]; then
          HASH=$(sha256sum vcpkg.json | cut -d' ' -f1)
        else
          HASH="novcpkg"
        fi
        echo "HASH=$HASH" >> "$GITHUB_ENV"
        echo "HASH=$HASH" >> "$GITHUB_OUTPUT"

    - name: Compute vcpkg.json hash (Windows)
      id: vcpkg_hash_win
      if: ${{ runner.os == 'Windows' }}
      shell: pwsh
      run: |
        if (Test-Path "vcpkg.json") {
          $HASH = (Get-FileHash vcpkg.json -Algorithm SHA256).Hash
        } else {
          $HASH = "novcpkg"
        }
        echo "HASH=$HASH" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ASCII
        echo "HASH=$HASH" >> $GITHUB_OUTPUT

    - name: Cache vcpkg (Linux/macOS)
      if: ${{ inputs.use_vcpkg_cache == 'true' && runner.os != 'Windows' }}
      uses: actions/cache@v4
      with:
        path: |
          build/vcpkg_installed
          build/vcpkg_downloads
        key: ${{ runner.os }}-vcpkg-${{ steps.vcpkg_hash.outputs.HASH }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-

    - name: Cache vcpkg (Windows)
      if: ${{ inputs.use_vcpkg_cache == 'true' && runner.os == 'Windows' }}
      uses: actions/cache@v4
      with:
        path: |
          build/vcpkg_installed
          build/vcpkg_downloads
        key: ${{ runner.os }}-vcpkg-${{ steps.vcpkg_hash_win.outputs.HASH }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-


    # --------------------------
    # OS dependencies
    # --------------------------
    - name: Install dependencies (Linux)
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      run: |
        sudo apt-get update -y
        sudo apt-get install -y \
          gcc-multilib \
          g++-multilib \
          build-essential \
          ninja-build \
          libsdl2-dev \
          libsdl2-ttf-dev \
          libltdl-dev

    - name: Install dependencies (macOS)
      if: ${{ runner.os == 'macOS' }}
      shell: bash
      run: |
        brew update
        brew install autoconf autoconf-archive automake libtool make cmake ninja
        echo "VCPKG_CMAKE_GENERATOR=Ninja" >> "$GITHUB_ENV"

    # --------------------------
    # Configure
    # --------------------------
    - name: Configure CMake (Linux/macOS)
      if: ${{ runner.os != 'Windows' }}
      shell: bash
      run: |
        cmake -S . -B build \
          -DCMAKE_BUILD_TYPE=${{ inputs.build_type }} \
          -DENABLE_TESTS=${{ inputs.enable_tests == 'true' && 'ON' || 'OFF' }}

    - name: Configure CMake (Windows)
      if: ${{ runner.os == 'Windows' }}
      shell: pwsh
      run: |
        $enableTests = if ("${{ inputs.enable_tests }}" -eq "true") { "ON" } else { "OFF" }
        cmake -S . -B build `
          -DCMAKE_BUILD_TYPE="${{ inputs.build_type }}" `
          -DENABLE_TESTS="$enableTests"

    # --------------------------
    # Build
    # --------------------------
    - name: Build (Linux/macOS)
      if: ${{ runner.os != 'Windows' }}
      shell: bash
      run: |
        cmake --build build \
          --config ${{ inputs.build_type }} \
          --parallel $JOBS

    - name: Build (Windows)
      if: ${{ runner.os == 'Windows' }}
      shell: pwsh
      run: |
        cmake --build build `
          --config "${{ inputs.build_type }}" `
          --parallel $env:JOBS

    # --------------------------
    # Sign binaries
    # --------------------------
    - name: Sign binaries
      if: ${{ inputs.sign_binaries == 'true' }}
      uses: sigstore/cosign-installer@v4.0.0

    - name: Sign binaries (Linux/macOS)
      if: ${{ inputs.sign_binaries == 'true' && runner.os != 'Windows' }}
      shell: bash
      env:
        COSIGN_EXPERIMENTAL: "true"
        COSIGN_OIDC_PROVIDER: "github-actions"
      run: |
        set -euo pipefail

        BIN_DIR="bin/${{ inputs.build_type }}"
        echo "Searching for binaries in: $BIN_DIR"

        # Collect file list (bash 3 compatible for macOS)
        FILES=()
        while IFS= read -r f; do
          FILES+=("$f")
        done < <(find "$BIN_DIR" -type f \( \
            -name "*.so" -o \
            -name "*.a" -o \
            -name "*.dylib" -o \
            -name "*.tpl" -o \
            -name "*.gpl" \
          \))

        if [ "${#FILES[@]}" -eq 0 ]; then
          echo "No binaries found to sign."
          exit 0
        fi

        echo "Signing ${#FILES[@]} binaries..."

        # cosign sign-blob does not support --files across versions; sign one by one.
        for f in "${FILES[@]}"; do
          cosign sign-blob \
            --yes \
            --output-signature "$f.sig" \
            --output-certificate "$f.cert" \
            --bundle "$f.bundle" \
            "$f"
        done

        echo "Signing completed successfully."


    - name: Sign binaries (Windows)
      if: ${{ inputs.sign_binaries == 'true' && runner.os == 'Windows' }}
      shell: pwsh
      env:
        COSIGN_EXPERIMENTAL: "true"
        COSIGN_OIDC_PROVIDER: "github-actions"
      run: |
        $ErrorActionPreference = "Stop"

        $binDir = "bin\${{ inputs.build_type }}"
        Write-Host "Searching for binaries in $binDir"

        $patterns = @("*.dll", "*.exe", "*.tpl", "*.gpl")
        $files = @()

        foreach ($pattern in $patterns) {
          $files += Get-ChildItem -Path $binDir -Recurse -Filter $pattern -File
        }

        if ($files.Count -eq 0) {
          Write-Host "No binaries found to sign."
          exit 0
        }

        Write-Host "Signing $($files.Count) binaries..."

        foreach ($f in $files) {
          cosign sign-blob `
            --yes `
            --output-signature "$($f.FullName).sig" `
            --output-certificate "$($f.FullName).cert" `
            --bundle "$($f.FullName).bundle" `
            $f.FullName

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Cosign failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }
        }

        Write-Host "Signing completed successfully."



    # --------------------------
    # Tests
    # --------------------------
    - name: Run tests (Linux/macOS)
      if: ${{ inputs.enable_tests == 'true' && runner.os != 'Windows' }}
      shell: bash
      run: |
        ctest --test-dir build --output-on-failure

    - name: Run tests (Windows)
      if: ${{ inputs.enable_tests == 'true' && runner.os == 'Windows' }}
      shell: pwsh
      run: |
        ctest --test-dir build --output-on-failure

    # --------------------------
    # Artifact packaging
    # --------------------------
    - name: Package artifact (Linux/macOS)
      if: ${{ inputs.upload_artifact == 'true' && runner.os != 'Windows' }}
      shell: bash
      run: |
        zip_name="build-${{ runner.os }}-${{ inputs.build_type }}.zip"
        zip -9 -r "$zip_name" ${{ inputs.artifact_path }}
        echo "AZIP=$PWD/$zip_name" >> "$GITHUB_ENV"

    - name: Package artifact (Windows)
      if: ${{ inputs.upload_artifact == 'true' && runner.os == 'Windows' }}
      shell: pwsh
      run: |
        $zipName = "build-${{ runner.os }}-${{ inputs.build_type }}.zip"
        $artifactRoot = Join-Path $Env:GITHUB_WORKSPACE "bin\${{ inputs.build_type }}"
        if (!(Test-Path $artifactRoot)) { Write-Host "No files matched: $artifactRoot"; exit 1 }
        $files = Get-ChildItem -Path $artifactRoot -Recurse -File
        if (!$files) { Write-Host "No files matched: $artifactRoot"; exit 1 }
        $dest = Join-Path $Env:GITHUB_WORKSPACE $zipName
        if (Test-Path $dest) { Remove-Item $dest }
        Compress-Archive -Path ($files.FullName) -DestinationPath $dest -Force
        "AZIP=$dest" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ASCII

    # --------------------------
    # Upload
    # --------------------------
    - name: Upload artifact
      if: ${{ inputs.upload_artifact == 'true' && env.AZIP != '' }}
      uses: actions/upload-artifact@v4
      with:
        name: build-${{ runner.os }}-${{ inputs.build_type }}
        path: ${{ env.AZIP }}
        retention-days: 1
