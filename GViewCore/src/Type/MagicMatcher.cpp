#include <Internal.hpp>

namespace GView::Type::Matcher
{
constexpr uint8 SEP = 0xFE;

#define GET_WORD(p)  (*(reinterpret_cast<const uint16*>(p)))
#define GET_DWORD(p) (*(reinterpret_cast<const uint32*>(p)))
#define GET_QWORD(p) (*(reinterpret_cast<const uint64*>(p)))

uint8 hexCharTypes[256] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, SEP,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, SEP,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    0xFF, SEP,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 10,
    11,   12,   13,   14,   15,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 10,   11,   12,   13,   14,   15,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};
bool MagicMatcher::Init(std::string_view text)
{
    // format is HH HH HH HH .... or
    //           HH,HH,HH,HH, ....
    const uint8* p = reinterpret_cast<const uint8*>(text.data());
    const uint8* e = p + text.size();
    while (p < e)
    {
        while ((p < e) && (hexCharTypes[*p] == SEP))
            p++;
        if (p >= e)
            break;
        CHECK(p + 2 <= e, false, "");
        auto v1 = hexCharTypes[*p];
        auto v2 = hexCharTypes[p[1]];
        CHECK((v1 <= 15) && (v2 <= 15), false, "");
        this->u8[count++] = (v1 << 4) | v2;
        if (count >= ARRAY_LEN(this->u8))
            break;
        p += 2;
    }
    // all good
    return count>0;
}
bool MagicMatcher::Match(AppCUI::Utils::BufferView buf, TextParser& )
{
    const auto* p = buf.GetData();
    CHECK(buf.GetLength() >= count, false, "");
    switch (count)
    {
    case 0:
        return false; // no match
    case 1:
        return (*p) == (*u8);
    case 2:
        return GET_WORD(p) == (*u16);
    case 3:
        return (GET_WORD(p) == (*u16)) && (p[2] == u8[2]);
    case 4:
        return GET_DWORD(p) == (*u32);
    case 5:
        return (GET_DWORD(p) == (*u32)) && (p[4] == u8[4]);
    case 6:
        return (GET_DWORD(p) == (*u32)) && (GET_WORD(p + 4) == u16[2]);
    case 7:
        return (GET_DWORD(p) == (*u32)) && (GET_WORD(p + 4) == u16[2]) && (p[6] == u8[6]);
    case 8:
        return GET_QWORD(p) == (*u64);
    default:
        return memcmp(p, u8, count) == 0;
    }
}

} // namespace GView::Type::Matcher